/**
 * Change Applier - Applies approved changes to the system
 */

const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

class ChangeApplier {
  constructor(options = {}) {
    this.basePath = options.basePath || '/root/.openclaw/workspace/knowledge-system';
    this.configPath = options.configPath || '/root/.openclaw/workspace/knowledge-system/config';
    this.skillsPath = options.skillsPath || '/root/.openclaw/workspace/knowledge-system/lib';
    this.backupPath = options.backupPath || '/var/lib/knowledge/backups';
  }

  async init() {
    await fs.mkdir(this.backupPath, { recursive: true });
    await fs.mkdir(this.configPath, { recursive: true });
  }

  /**
   * Apply a change based on its type
   */
  async apply(proposal) {
    const { type, change } = proposal;
    
    console.log(`[ChangeApplier] Applying ${type}:`, proposal.id);
    
    // Create backup before applying (for L3/L4)
    if (proposal.level === 'L3' || proposal.level === 'L4') {
      await this.createBackup(proposal);
    }
    
    try {
      switch (type) {
        case 'config':
          return await this.applyConfig(change);
        case 'new_skill':
          return await this.applyNewSkill(change, proposal);
        case 'update':
          return await this.applyUpdate(change, proposal);
        case 'self_modification':
          return await this.applySelfModification(change, proposal);
        default:
          throw new Error(`Unknown change type: ${type}`);
      }
    } catch (err) {
      // Attempt rollback for L3/L4
      if (proposal.level === 'L3' || proposal.level === 'L4') {
        await this.rollback(proposal);
      }
      throw err;
    }
  }

  /**
   * Apply config changes
   */
  async applyConfig(change) {
    const configFile = path.join(this.configPath, 'evolution.yml');
    
    // Read existing or create new
    let config = {};
    try {
      const content = await fs.readFile(configFile, 'utf8');
      config = require('js-yaml').load(content) || {};
    } catch {
      // File doesn't exist, start fresh
    }
    
    // Apply changes
    Object.assign(config, change.settings || {});
    
    // Write back
    const yaml = require('js-yaml').dump(config);
    await fs.writeFile(configFile, yaml);
    
    console.log(`[ChangeApplier] Config updated:`, change.settings);
    
    return { applied: true, type: 'config', path: configFile };
  }

  /**
   * Apply new skill creation
   */
  async applyNewSkill(change, proposal) {
    const { skill } = change;
    if (!skill || !skill.name) {
      throw new Error('Skill name is required');
    }
    
    const skillDir = path.join(this.skillsPath, skill.name);
    await fs.mkdir(skillDir, { recursive: true });
    await fs.mkdir(path.join(skillDir, 'scripts'), { recursive: true });
    await fs.mkdir(path.join(skillDir, 'references'), { recursive: true });
    
    // Create SKILL.md
    const skillMd = `---
name: ${skill.name}
description: ${skill.description || 'Auto-generated skill'}
source: self-evolution
created: ${new Date().toISOString()}
approved: ${proposal?.id || 'unknown'}
---

# ${skill.name}

${skill.description || 'No description provided.'}

## Usage

\`\`\`javascript
const { ${this.toClassName(skill.name)} } = require('./skills/${skill.name}');

// Initialize skill
const skill = new ${this.toClassName(skill.name)}();

// Run skill with input data
const result = await skill.run({
  context: 'session-data',
  parameters: { /* skill-specific params */ }
});

// Check result
if (result.success) {
  console.log('Skill executed successfully:', result.data);
} else {
  console.error('Skill failed:', result.error);
}
\`\`\`

## Integration with Self-Evolution System

This skill is automatically invoked by the Evolution system when patterns are detected.
See \`SKILL.md\` for detailed usage instructions.
`;
    
    await fs.writeFile(path.join(skillDir, 'SKILL.md'), skillMd);
    
    // Create main script file using function to avoid template literal nesting issues
    const skillName = skill.name;
    const skillDesc = skill.description || '';
    const className = this.toClassName(skill.name);
    const skillType = skill.type || 'pattern';
    const patternsStr = skill.patterns ? skill.patterns.map(p => "new RegExp('" + p + "', 'i')").join(',\n      ') : '// Add patterns here';
    
    const mainScriptParts = [
      '/**',
      ' * ' + skillName,
      ' * ' + skillDesc,
      ' * ',
      ' * This skill was auto-generated by the Self-Evolution System.',
      ' * It provides pattern detection and automated assistance.',
      ' */',
      '',
      'class ' + className + ' {',
      '  constructor(options = {}) {',
      '    this.options = options;',
      '    this.name = \'' + skillName + '\';',
      '    this.patterns = this.loadPatterns();',
      '  }',
      '',
      '  /**',
      '   * Load detection patterns for this skill',
      '   */',
      '  loadPatterns() {',
      '    // Patterns that trigger this skill',
      '    return [',
      '      ' + patternsStr,
      '    ];',
      '  }',
      '',
      '  /**',
      '   * Main entry point - analyze input and provide assistance',
      '   * @param {Object} input - Session context and message',
      '   * @returns {Object} Result with detection status and suggestions',
      '   */',
      '  async run(input) {',
      '    const { message, context } = input;',
      '    ',
      '    // Check if patterns match',
      '    const matchedPattern = this.detectPattern(message);',
      '    ',
      '    if (!matchedPattern) {',
      '      return {',
      '        success: true,',
      '        triggered: false,',
      "        reason: 'No matching patterns found'",
      '      };',
      '    }',
      '    ',
      '    // Analyze and provide assistance',
      '    const analysis = await this.analyze(input);',
      '    const suggestions = await this.generateSuggestions(analysis);',
      '    ',
      '    return {',
      '      success: true,',
      '      triggered: true,',
      '      pattern: matchedPattern,',
      '      analysis,',
      '      suggestions,',
      '      confidence: analysis.confidence || 0.8',
      '    };',
      '  }',
      '',
      '  /**',
      '   * Detect if message matches any known patterns',
      '   */',
      '  detectPattern(message) {',
      '    const text = typeof message === \'string\' ? message : JSON.stringify(message);',
      '    ',
      '    for (const pattern of this.patterns) {',
      '      if (pattern.test(text)) {',
      '        return pattern.toString();',
      '      }',
      '    }',
      '    ',
      '    return null;',
      '  }',
      '',
      '  /**',
      '   * Analyze the input context',
      '   */',
      '  async analyze(input) {',
      '    const { message, context } = input;',
      '    ',
      '    // Perform analysis based on skill type',
      '    return {',
      "      type: '" + skillType + "',",
      '      severity: this.assessSeverity(message),',
      '      context: context || {},',
      '      confidence: 0.8,',
      "      timestamp: new Date().toISOString()",
      '    };',
      '  }',
      '',
      '  /**',
      '   * Assess severity of the detected issue',
      '   */',
      '  assessSeverity(message) {',
      '    const text = String(message).toLowerCase();',
      '    ',
      "    if (text.includes('error') || text.includes('fail')) return 'high';",
      "    if (text.includes('warning') || text.includes('deprecated')) return 'medium';",
      "    return 'low';",
      '  }',
      '',
      '  /**',
      '   * Generate suggestions based on analysis',
      '   */',
      '  async generateSuggestions(analysis) {',
      '    // Return context-aware suggestions',
      '    return [',
      '      {',
      "        type: 'best_practice',",
      "        message: 'Consider reviewing best practices for this pattern',",
      "        action: 'review_docs'",
      '      },',
      '      {',
      "        type: 'prevention',",
      "        message: 'This pattern can be prevented with proper setup',",
      "        action: 'check_config'",
      '      }',
      '    ];',
      '  }',
      '',
      '  /**',
      '   * Get skill metadata',
      '   */',
      '  getInfo() {',
      '    return {',
      "      name: this.name,",
      "      description: '" + (skillDesc.replace(/'/g, "\\'") || 'Auto-generated skill') + "',",
      '      patterns: this.patterns.length,',
      "      version: '1.0.0'",
      '    };',
      '  }',
      '}',
      '',
      'module.exports = { ' + className + ' };'
    ];
    
    const mainScript = mainScriptParts.join('\n');
    
    await fs.writeFile(
      path.join(skillDir, 'scripts', skillName + '.js'),
      mainScript
    );
    
    // Create test file
    const testScript = `/**
 * Tests for ${skill.name}
 */

const { ${this.toClassName(skill.name)} } = require('./${skill.name}');

async function runTests() {
  console.log('Testing ${skill.name}...');
  
  const skill = new ${this.toClassName(skill.name)}();
  
  // Test 1: Basic initialization
  console.log('Test 1: Initialization');
  console.assert(skill !== null, 'Skill should initialize');
  console.log('  ✅ PASSED');
  
  // Test 2: Run method
  console.log('Test 2: Run method');
  const result = await skill.run({ test: true });
  console.assert(result.success === true, 'Run should return success');
  console.log('  ✅ PASSED');
  
  console.log('\\n=== All Tests PASSED ✅ ===');
}

runTests().catch(err => {
  console.error('❌ Test failed:', err);
  process.exit(1);
});
`;
    
    await fs.writeFile(
      path.join(skillDir, 'scripts', `${skill.name}.test.js`),
      testScript
    );
    
    // Create package.json
    const packageJson = {
      name: skill.name,
      version: '1.0.0',
      description: skill.description || `Self-evolution skill: ${skill.name}`,
      main: `scripts/${skill.name}.js`,
      scripts: {
        test: `node scripts/${skill.name}.test.js`
      },
      keywords: ['self-evolution', 'skill'],
      author: 'Self-Evolution System',
      license: 'MIT'
    };
    
    await fs.writeFile(
      path.join(skillDir, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );
    
    // Update skills index
    await this.updateSkillsIndex(skill.name);
    
    // Git commit
    try {
      await execAsync(
        `cd ${this.basePath} && git add ${skillDir} && git commit -m "feat(skill): add ${skill.name} - ${skill.description?.substring(0, 50) || 'auto-generated'}"`,
        { timeout: 30000 }
      );
      console.log(`[ChangeApplier] Git commit created for ${skill.name}`);
    } catch (err) {
      console.warn(`[ChangeApplier] Git commit failed (non-critical): ${err.message}`);
    }
    
    // NPM install (only if package.json has dependencies)
    if (packageJson.dependencies && Object.keys(packageJson.dependencies).length > 0) {
      try {
        await execAsync(
          `cd ${skillDir} && npm install`,
          { timeout: 60000 }
        );
        console.log(`[ChangeApplier] NPM install completed for ${skill.name}`);
      } catch (err) {
        console.warn(`[ChangeApplier] NPM install failed (non-critical): ${err.message}`);
      }
    } else {
      console.log(`[ChangeApplier] No dependencies to install for ${skill.name}`);
    }
    
    console.log(`[ChangeApplier] Skill created:`, skillDir);
    
    return { 
      applied: true, 
      type: 'new_skill', 
      path: skillDir,
      skill: skill.name 
    };
  }

  /**
   * Apply update to existing component
   */
  async applyUpdate(change, proposal) {
    const { target, updates } = change;
    
    if (!target) {
      throw new Error('Update target is required');
    }
    
    // Find target file
    const targetPath = await this.findTarget(target);
    if (!targetPath) {
      throw new Error(`Target not found: ${target}`);
    }
    
    // Read current content
    const content = await fs.readFile(targetPath, 'utf8');
    
    // Apply updates (simple key-value replacement for now)
    let newContent = content;
    if (updates?.replacements) {
      for (const [oldStr, newStr] of Object.entries(updates.replacements)) {
        newContent = newContent.replace(oldStr, newStr);
      }
    }
    
    // Write updated content
    await fs.writeFile(targetPath, newContent);
    
    console.log(`[ChangeApplier] Updated:`, targetPath);
    
    return { applied: true, type: 'update', path: targetPath };
  }

  /**
   * Apply self-modification (critical)
   */
  async applySelfModification(change, proposal) {
    const { component, modification } = change;
    
    console.log(`[ChangeApplier] SELF-MODIFICATION:`, component);
    
    // Extra safety: validate modification
    if (!modification || !modification.safe) {
      throw new Error('Self-modification must be marked as safe');
    }
    
    // Apply based on component
    switch (component) {
      case 'approval-manager':
        return await this.modifyApprovalManager(modification);
      case 'learning-log':
        return await this.modifyLearningLog(modification);
      default:
        throw new Error(`Unknown component for self-modification: ${component}`);
    }
  }

  /**
   * Create backup before applying
   */
  async createBackup(proposal) {
    const backupDir = path.join(this.backupPath, proposal.id);
    await fs.mkdir(backupDir, { recursive: true });
    
    // Backup config
    try {
      await fs.copyFile(
        path.join(this.configPath, 'evolution.yml'),
        path.join(backupDir, 'evolution.yml')
      );
    } catch {}
    
    // Backup relevant source files
    const filesToBackup = await this.getFilesToBackup(proposal);
    for (const file of filesToBackup) {
      try {
        const backupFile = path.join(backupDir, path.basename(file));
        await fs.copyFile(file, backupFile);
      } catch {}
    }
    
    console.log(`[ChangeApplier] Backup created:`, backupDir);
    
    return backupDir;
  }

  /**
   * Rollback changes on failure
   */
  async rollback(proposal) {
    const backupDir = path.join(this.backupPath, proposal.id);
    
    try {
      // Restore from backup
      const files = await fs.readdir(backupDir);
      for (const file of files) {
        const backupFile = path.join(backupDir, file);
        const targetFile = path.join(this.configPath, file);
        await fs.copyFile(backupFile, targetFile);
      }
      
      console.log(`[ChangeApplier] Rollback completed:`, proposal.id);
      return { rolledBack: true };
    } catch (err) {
      console.error(`[ChangeApplier] Rollback failed:`, err.message);
      return { rolledBack: false, error: err.message };
    }
  }

  /**
   * Find target file for update
   */
  async findTarget(target) {
    const possiblePaths = [
      path.join(this.basePath, 'src', target + '.js'),
      path.join(this.basePath, 'src', 'evolution', target + '.js'),
      path.join(this.basePath, 'scripts', target + '.js'),
      path.join(this.basePath, 'config', target + '.yml'),
    ];
    
    for (const p of possiblePaths) {
      try {
        await fs.access(p);
        return p;
      } catch {}
    }
    
    return null;
  }

  /**
   * Get files to backup for proposal
   */
  async getFilesToBackup(proposal) {
    const files = [];
    
    switch (proposal.type) {
      case 'config':
        files.push(path.join(this.configPath, 'evolution.yml'));
        break;
      case 'new_skill':
        // No need to backup, creating new
        break;
      case 'update':
        const target = await this.findTarget(proposal.change.target);
        if (target) files.push(target);
        break;
      case 'self_modification':
        // Backup all evolution files
        const evolutionDir = path.join(this.basePath, 'src', 'evolution');
        try {
          const evoFiles = await fs.readdir(evolutionDir);
          for (const f of evoFiles) {
            if (f.endsWith('.js')) {
              files.push(path.join(evolutionDir, f));
            }
          }
        } catch {}
        break;
    }
    
    return files;
  }

  /**
   * Convert skill name to class name
   */
  toClassName(name) {
    return name
      .split('-')
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Update skills index file
   */
  async updateSkillsIndex(skillName) {
    const indexPath = path.join(this.skillsPath, 'index.js');
    
    let indexContent = '';
    try {
      indexContent = await fs.readFile(indexPath, 'utf8');
    } catch {
      // Create new index file
      indexContent = '/**\n * Skills Index\n * Auto-generated by Self-Evolution System\n */\n\n';
    }
    
    // Add export for new skill if not exists
    const exportLine = `module.exports.${this.toClassName(skillName)} = require('./${skillName}/scripts/${skillName}').${this.toClassName(skillName)};`;
    
    if (!indexContent.includes(skillName)) {
      indexContent += exportLine + '\n';
      await fs.writeFile(indexPath, indexContent);
      console.log(`[ChangeApplier] Updated skills index: ${skillName}`);
    }
  }

  /**
   * Modify approval manager (self-mod)
   */
  async modifyApprovalManager(modification) {
    // This is dangerous - only allow specific safe changes
    if (modification.type === 'update_thresholds') {
      // Safe: just update threshold values
      const configFile = path.join(this.configPath, 'approval-levels.yml');
      let config = {};
      try {
        const content = await fs.readFile(configFile, 'utf8');
        config = require('js-yaml').load(content) || {};
      } catch {}
      
      Object.assign(config, modification.thresholds || {});
      
      const yaml = require('js-yaml').dump(config);
      await fs.writeFile(configFile, yaml);
      
      return { applied: true, type: 'self_modification', component: 'approval-manager' };
    }
    
    throw new Error('Unsupported self-modification type');
  }

  /**
   * Modify learning log (self-mod)
   */
  async modifyLearningLog(modification) {
    if (modification.type === 'update_retention') {
      // Safe: just update retention days
      const configFile = path.join(this.configPath, 'evolution.yml');
      let config = {};
      try {
        const content = await fs.readFile(configFile, 'utf8');
        config = require('js-yaml').load(content) || {};
      } catch {}
      
      config.retentionDays = modification.days || 30;
      
      const yaml = require('js-yaml').dump(config);
      await fs.writeFile(configFile, yaml);
      
      return { applied: true, type: 'self_modification', component: 'learning-log' };
    }
    
    throw new Error('Unsupported self-modification type');
  }
}

module.exports = { ChangeApplier };
